// Configuration object that maps agent names to their result files
window.agentResultsConfig = {
  'data-analyst': {
    claude: {
      1: 'results_claude_sonnet/analysis_iteration_0.txt',
      2: 'results_claude_sonnet/analysis_iteration_1.txt',
      3: 'results_claude_sonnet/analysis_iteration_2.txt',
      4: 'results_claude_sonnet/analysis_iteration_3.txt',
      5: 'results_claude_sonnet/analysis_iteration_4.txt',
      6: 'results_claude_sonnet/analysis_iteration_5.txt',
      7: 'results_claude_sonnet/analysis_iteration_6.txt',
      8: 'results_claude_sonnet/analysis_iteration_7.txt',
      9: 'results_claude_sonnet/analysis_iteration_8.txt',
      10: 'results_claude_sonnet/analysis_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/analysis_iteration_0.txt',
      2: 'results_gemini_flash2/analysis_iteration_1.txt',
      3: 'results_gemini_flash2/analysis_iteration_2.txt',
      4: 'results_gemini_flash2/analysis_iteration_3.txt',
      5: 'results_gemini_flash2/analysis_iteration_4.txt',
      6: 'results_gemini_flash2/analysis_iteration_5.txt',
      7: 'results_gemini_flash2/analysis_iteration_6.txt',
      8: 'results_gemini_flash2/analysis_iteration_7.txt',
      9: 'results_gemini_flash2/analysis_iteration_8.txt',
      10: 'results_gemini_flash2/analysis_iteration_9.txt',
    }
  },
  'planner': {
    claude: {
      1: 'results_claude_sonnet/planning_instructions_iteration_0.txt',
      2: 'results_claude_sonnet/planning_instructions_iteration_1.txt',
      3: 'results_claude_sonnet/planning_instructions_iteration_2.txt',
      4: 'results_claude_sonnet/planning_instructions_iteration_3.txt',
      5: 'results_claude_sonnet/planning_instructions_iteration_4.txt',
      6: 'results_claude_sonnet/planning_instructions_iteration_5.txt',
      7: 'results_claude_sonnet/planning_instructions_iteration_6.txt',
      8: 'results_claude_sonnet/planning_instructions_iteration_7.txt',
      9: 'results_claude_sonnet/planning_instructions_iteration_8.txt',
      10: 'results_claude_sonnet/planning_instructions_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/planning_instructions_iteration_0.txt',
      2: 'results_gemini_flash2/planning_instructions_iteration_1.txt',
      3: 'results_gemini_flash2/planning_instructions_iteration_2.txt',
      4: 'results_gemini_flash2/planning_instructions_iteration_3.txt',
      5: 'results_gemini_flash2/planning_instructions_iteration_4.txt',
      6: 'results_gemini_flash2/planning_instructions_iteration_5.txt',
      7: 'results_gemini_flash2/planning_instructions_iteration_6.txt',
      8: 'results_gemini_flash2/planning_instructions_iteration_7.txt',
      9: 'results_gemini_flash2/planning_instructions_iteration_8.txt',
      10: 'results_gemini_flash2/planning_instructions_iteration_9.txt',
    }
  },
  'scientist-1': {
    claude: {
      1: 'results_claude_sonnet/hypothesis_1_iteration_0.txt',
      2: 'results_claude_sonnet/hypothesis_1_iteration_1.txt',
      3: 'results_claude_sonnet/hypothesis_1_iteration_2.txt',
      4: 'results_claude_sonnet/hypothesis_1_iteration_3.txt',
      5: 'results_claude_sonnet/hypothesis_1_iteration_4.txt',
      6: 'results_claude_sonnet/hypothesis_1_iteration_5.txt',
      7: 'results_claude_sonnet/hypothesis_1_iteration_6.txt',
      8: 'results_claude_sonnet/hypothesis_1_iteration_7.txt',
      9: 'results_claude_sonnet/hypothesis_1_iteration_8.txt',
      10: 'results_claude_sonnet/hypothesis_1_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/hypothesis_1_iteration_0.txt',
      2: 'results_gemini_flash2/hypothesis_1_iteration_1.txt',
      3: 'results_gemini_flash2/hypothesis_1_iteration_2.txt',
      4: 'results_gemini_flash2/hypothesis_1_iteration_3.txt',
      5: 'results_gemini_flash2/hypothesis_1_iteration_4.txt',
      6: 'results_gemini_flash2/hypothesis_1_iteration_5.txt',
      7: 'results_gemini_flash2/hypothesis_1_iteration_6.txt',
      8: 'results_gemini_flash2/hypothesis_1_iteration_7.txt',
      9: 'results_gemini_flash2/hypothesis_1_iteration_8.txt',
      10: 'results_gemini_flash2/hypothesis_1_iteration_9.txt',
    }
  },
  'scientist-2': {
    claude: {
      1: 'results_claude_sonnet/hypothesis_2_iteration_0.txt',
      2: 'results_claude_sonnet/hypothesis_2_iteration_1.txt',
      3: 'results_claude_sonnet/hypothesis_2_iteration_2.txt',
      4: 'results_claude_sonnet/hypothesis_2_iteration_3.txt',
      5: 'results_claude_sonnet/hypothesis_2_iteration_4.txt',
      6: 'results_claude_sonnet/hypothesis_2_iteration_5.txt',
      7: 'results_claude_sonnet/hypothesis_2_iteration_6.txt',
      8: 'results_claude_sonnet/hypothesis_2_iteration_7.txt',
      9: 'results_claude_sonnet/hypothesis_2_iteration_8.txt',
      10: 'results_claude_sonnet/hypothesis_2_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/hypothesis_2_iteration_0.txt',
      2: 'results_gemini_flash2/hypothesis_2_iteration_1.txt',
      3: 'results_gemini_flash2/hypothesis_2_iteration_2.txt',
      4: 'results_gemini_flash2/hypothesis_2_iteration_3.txt',
      5: 'results_gemini_flash2/hypothesis_2_iteration_4.txt',
      6: 'results_gemini_flash2/hypothesis_2_iteration_5.txt',
      7: 'results_gemini_flash2/hypothesis_2_iteration_6.txt',
      8: 'results_gemini_flash2/hypothesis_2_iteration_7.txt',
      9: 'results_gemini_flash2/hypothesis_2_iteration_8.txt',
      10: 'results_gemini_flash2/hypothesis_2_iteration_9.txt',
    }
  },
  'scientist-3': {
    claude: {
      1: 'results_claude_sonnet/hypothesis_3_iteration_0.txt',
      2: 'results_claude_sonnet/hypothesis_3_iteration_1.txt',
      3: 'results_claude_sonnet/hypothesis_3_iteration_2.txt',
      4: 'results_claude_sonnet/hypothesis_3_iteration_3.txt',
      5: 'results_claude_sonnet/hypothesis_3_iteration_4.txt',
      6: 'results_claude_sonnet/hypothesis_3_iteration_5.txt',
      7: 'results_claude_sonnet/hypothesis_3_iteration_6.txt',
      8: 'results_claude_sonnet/hypothesis_3_iteration_7.txt',
      9: 'results_claude_sonnet/hypothesis_3_iteration_8.txt',
      10: 'results_claude_sonnet/hypothesis_3_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/hypothesis_3_iteration_0.txt',
      2: 'results_gemini_flash2/hypothesis_3_iteration_1.txt',
      3: 'results_gemini_flash2/hypothesis_3_iteration_2.txt',
      4: 'results_gemini_flash2/hypothesis_3_iteration_3.txt',
      5: 'results_gemini_flash2/hypothesis_3_iteration_4.txt',
      6: 'results_gemini_flash2/hypothesis_3_iteration_5.txt',
      7: 'results_gemini_flash2/hypothesis_3_iteration_6.txt',
      8: 'results_gemini_flash2/hypothesis_3_iteration_7.txt',
      9: 'results_gemini_flash2/hypothesis_3_iteration_8.txt',
      10: 'results_gemini_flash2/hypothesis_3_iteration_9.txt',
    }
  },
  'accumulator': {
    claude: {
      1: 'results_claude_sonnet/accumulated_hypothesis_iteration_0.txt',
      2: 'results_claude_sonnet/accumulated_hypothesis_iteration_1.txt',
      3: 'results_claude_sonnet/accumulated_hypothesis_iteration_2.txt',
      4: 'results_claude_sonnet/accumulated_hypothesis_iteration_3.txt',
      5: 'results_claude_sonnet/accumulated_hypothesis_iteration_4.txt',
      6: 'results_claude_sonnet/accumulated_hypothesis_iteration_5.txt',
      7: 'results_claude_sonnet/accumulated_hypothesis_iteration_6.txt',
      8: 'results_claude_sonnet/accumulated_hypothesis_iteration_7.txt',
      9: 'results_claude_sonnet/accumulated_hypothesis_iteration_8.txt',
      10: 'results_claude_sonnet/accumulated_hypothesis_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/accumulated_hypothesis_iteration_0.txt',
      2: 'results_gemini_flash2/accumulated_hypothesis_iteration_1.txt',
      3: 'results_gemini_flash2/accumulated_hypothesis_iteration_2.txt',
      4: 'results_gemini_flash2/accumulated_hypothesis_iteration_3.txt',
      5: 'results_gemini_flash2/accumulated_hypothesis_iteration_4.txt',
      6: 'results_gemini_flash2/accumulated_hypothesis_iteration_5.txt',
      7: 'results_gemini_flash2/accumulated_hypothesis_iteration_6.txt',
      8: 'results_gemini_flash2/accumulated_hypothesis_iteration_7.txt',
      9: 'results_gemini_flash2/accumulated_hypothesis_iteration_8.txt',
      10: 'results_gemini_flash2/accumulated_hypothesis_iteration_9.txt',
    }
  },
  'literature': {
    claude: {
      1: 'results_claude_sonnet/search_analysis_iteration_0.txt',
      2: 'results_claude_sonnet/search_analysis_iteration_1.txt',
      3: 'results_claude_sonnet/search_analysis_iteration_2.txt',
      4: 'results_claude_sonnet/search_analysis_iteration_3.txt',
      5: 'results_claude_sonnet/search_analysis_iteration_4.txt',
      6: 'results_claude_sonnet/search_analysis_iteration_5.txt',
      7: 'results_claude_sonnet/search_analysis_iteration_6.txt',
      8: 'results_claude_sonnet/search_analysis_iteration_7.txt',
      9: 'results_claude_sonnet/search_analysis_iteration_8.txt',
      10: 'results_claude_sonnet/search_analysis_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/search_analysis_iteration_0.txt',
      2: 'results_gemini_flash2/search_analysis_iteration_1.txt',
      3: 'results_gemini_flash2/search_analysis_iteration_2.txt',
      4: 'results_gemini_flash2/search_analysis_iteration_3.txt',
      5: 'results_gemini_flash2/search_analysis_iteration_4.txt',
      6: 'results_gemini_flash2/search_analysis_iteration_5.txt',
      7: 'results_gemini_flash2/search_analysis_iteration_6.txt',
      8: 'results_gemini_flash2/search_analysis_iteration_7.txt',
      9: 'results_gemini_flash2/search_analysis_iteration_8.txt',
      10: 'results_gemini_flash2/search_analysis_iteration_9.txt',
    }
  },
  'critic': {
    claude: {
      1: 'results_claude_sonnet/critic_feedback_iteration_0.txt',
      2: 'results_claude_sonnet/critic_feedback_iteration_1.txt',
      3: 'results_claude_sonnet/critic_feedback_iteration_2.txt',
      4: 'results_claude_sonnet/critic_feedback_iteration_3.txt',
      5: 'results_claude_sonnet/critic_feedback_iteration_4.txt',
      6: 'results_claude_sonnet/critic_feedback_iteration_5.txt',
      7: 'results_claude_sonnet/critic_feedback_iteration_6.txt',
      8: 'results_claude_sonnet/critic_feedback_iteration_7.txt',
      9: 'results_claude_sonnet/critic_feedback_iteration_8.txt',
      10: 'results_claude_sonnet/critic_feedback_iteration_9.txt',
    },
    gemini: {
      1: 'results_gemini_flash2/critic_feedback_iteration_0.txt',
      2: 'results_gemini_flash2/critic_feedback_iteration_1.txt',
      3: 'results_gemini_flash2/critic_feedback_iteration_2.txt',
      4: 'results_gemini_flash2/critic_feedback_iteration_3.txt',
      5: 'results_gemini_flash2/critic_feedback_iteration_4.txt',
      6: 'results_gemini_flash2/critic_feedback_iteration_5.txt',
      7: 'results_gemini_flash2/critic_feedback_iteration_6.txt',
      8: 'results_gemini_flash2/critic_feedback_iteration_7.txt',
      9: 'results_gemini_flash2/critic_feedback_iteration_8.txt',
      10: 'results_gemini_flash2/critic_feedback_iteration_9.txt',
    }
  }
};

// Function to format plain text content for better HTML display
function formatContent(text) {
  // Check if the content contains JSON code blocks
  if (/```json\s*\{/.test(text)) {
    return formatTextWithJsonBlocks(text);
  }
  
  // Check if the content already has HTML tags
  if (/<[a-z][\s\S]*>/i.test(text)) {
    return text; // Already has HTML formatting
  }
  
  // Basic formatting for plain text
  let formatted = '';
  
  // Split by double newlines (paragraphs)
  const paragraphs = text.split(/\n\s*\n/);
  
  paragraphs.forEach(paragraph => {
    paragraph = paragraph.trim();
    
    // Skip empty paragraphs
    if (!paragraph) return;
    
    // Check if it's a list (starts with - or * or number.)
    if (/^(\s*[-*•]|\s*\d+\.)\s/.test(paragraph)) {
      // It's a list, convert to proper HTML list
      const lines = paragraph.split('\n');
      const listType = /^\s*\d+\./.test(lines[0]) ? 'ol' : 'ul';
      
      formatted += `<${listType}>`;
      
      lines.forEach(line => {
        if (!line.trim()) return;
        // Remove the list marker and create a list item
        let content = line.replace(/^\s*[-*•]|\s*\d+\.\s*/, '').trim();
        // Apply bold formatting within list items
        content = applyInlineFormatting(content);
        formatted += `<li>${content}</li>`;
      });
      
      formatted += `</${listType}>`;
    } 
    // Check if it's a heading (starts with #)
    else if (/^#+\s/.test(paragraph)) {
      const level = paragraph.match(/^(#+)\s/)[1].length;
      const headingLevel = Math.min(level, 6); // H1-H6
      const content = paragraph.replace(/^#+\s/, '');
      formatted += `<h${headingLevel}>${applyInlineFormatting(content)}</h${headingLevel}>`;
    }
    // Regular paragraph
    else {
      formatted += `<p>${applyInlineFormatting(paragraph)}</p>`;
    }
  });
  
  return formatted;
}

// Function to format text that contains JSON code blocks
function formatTextWithJsonBlocks(text) {
  let result = '';
  
  // Check if the text starts with 'json' or contains the JSON pattern
  if (text.trim().startsWith('json') || text.includes('```json')) {
    // Attempt to extract JSON content with more flexible pattern matching
    let jsonContent = text;
    
    // Remove markdown code block markers if present
    if (text.includes('```json')) {
      const matches = text.match(/```json\s*([\s\S]*?)\s*```/);
      if (matches && matches[1]) {
        jsonContent = matches[1];
      }
    }
    
    // Remove 'json' prefix if it's just at the beginning
    if (jsonContent.trim().startsWith('json')) {
      jsonContent = jsonContent.trim().substring(4).trim();
    }
    
    return processJsonContent(jsonContent);
  }
  
  // Standard processing for markdown with JSON blocks
  const parts = text.split(/```json\s*|\s*```/);
  
  for (let i = 0; i < parts.length; i++) {
    // Even indices are regular text, odd indices are JSON
    if (i % 2 === 0) {
      // Format regular text normally if it's not empty
      if (parts[i].trim()) {
        result += formatPlainText(parts[i]);
      }
    } else {
      // This is a JSON block - process it
      result += processJsonContent(parts[i]);
    }
  }
  
  return result;
}

// Special parser for planner files
function parsePlannerFile(text) {
  // Extract just the JSON part, ignoring any markdown or other content
  const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/);
  let jsonContent = jsonMatch ? jsonMatch[1] : text;
  
  // Try direct extraction of instructions if JSON parsing fails
  try {
    // First attempt normal JSON parsing
    return JSON.parse(jsonContent);
  } catch (error) {
    console.log("JSON parse error, trying direct extraction:", error);
    
    // Direct extraction using regex - more reliable for this specific format
    const agent1Match = jsonContent.match(/"Agent1_instructions"\s*:\s*"([^"]+)"/);
    const agent2Match = jsonContent.match(/"Agent2_instructions"\s*:\s*"([^"]+)"/);
    const agent3Match = jsonContent.match(/"Agent3_instructions"\s*:\s*"([^"]+)"/);
    
    // Create a valid JSON object with the extracted values
    const extractedObj = {};
    if (agent1Match && agent1Match[1]) extractedObj.Agent1_instructions = agent1Match[1];
    if (agent2Match && agent2Match[1]) extractedObj.Agent2_instructions = agent2Match[1];
    if (agent3Match && agent3Match[1]) extractedObj.Agent3_instructions = agent3Match[1];
    
    if (Object.keys(extractedObj).length > 0) {
      return extractedObj;
    }
    
    // If we couldn't extract the JSON, throw an error
    throw new Error("Failed to parse planner JSON content");
  }
}

// Modify the processJsonContent function to use our special parser
function processJsonContent(jsonText) {
  try {
    let jsonObj;
    
    // Special case for planner files (detected by content signature)
    if (jsonText.includes("Agent1_instructions") && 
        jsonText.includes("Agent2_instructions") && 
        jsonText.includes("Agent3_instructions")) {
      
      jsonObj = parsePlannerFile(jsonText);
    } else {
      // Standard JSON processing for other cases
      let cleanedJson = cleanJsonText(jsonText);
      jsonObj = JSON.parse(cleanedJson);
    }
    
    return formatJsonAsHtml(jsonObj);
  } catch (error) {
    console.warn("JSON parse error:", error, "in text:", jsonText);
    
    // Fallback display for when all parsing attempts fail
    return createPlannerFallbackDisplay(jsonText, error);
  }
}

// Create a simpler, more reliable fallback display specifically for planner instructions
function createPlannerFallbackDisplay(jsonText, error) {
  // Extract instruction content directly from text using simpler patterns
  const extractInstructionContent = (agentNum) => {
    const pattern = new RegExp(`Agent${agentNum}_instructions[^"]*"([^"]+)"`, 'i');
    const match = jsonText.match(pattern);
    return match ? match[1] : null;
  };
  
  const agent1 = extractInstructionContent(1);
  const agent2 = extractInstructionContent(2);
  const agent3 = extractInstructionContent(3);
  
  // Create nice HTML display for the extracted instructions
  let html = '<div class="agent-instructions">';
  
  // If we found any instructions, display them
  if (agent1 || agent2 || agent3) {
    if (agent1) html += createAgentBlock('1', agent1);
    if (agent2) html += createAgentBlock('2', agent2);
    if (agent3) html += createAgentBlock('3', agent3);
    
    html += '</div>';
    return html;
  }
  
  // If no instructions were found, show the error and raw content
  html += `<div class="json-error">Failed to parse planner instructions: ${error.message}</div>`;
  html += `<pre class="raw-json">${escapeHtml(jsonText)}</pre>`;
  html += '</div>';
  
  return html;
}

// Helper to create a formatted agent instruction block
function createAgentBlock(num, content) {
  return `
    <div class="instruction-block">
      <h3>Scientist ${num} Instructions</h3>
      <div class="instruction-content">${escapeHtml(content)}</div>
    </div>
  `;
}

// Function to clean and fix common JSON syntax issues
function cleanJsonText(jsonText) {
  // Remove non-printable characters and trim
  let cleaned = jsonText.replace(/[\x00-\x1F\x7F-\x9F]/g, '').trim();
  
  // Handle special case of malformed JSON that starts with {
  if (!cleaned.startsWith('{') && !cleaned.startsWith('[')) {
    // Check if there's a curly brace anywhere in the text
    if (cleaned.includes('{')) {
      // Extract content starting from the first '{'
      cleaned = cleaned.substring(cleaned.indexOf('{'));
    } else {
      // Wrap the content in curly braces if none exist
      cleaned = '{' + cleaned + '}';
    }
  }
  
  // Fix common JSON syntax errors
  
  // Remove trailing commas
  cleaned = cleaned.replace(/,\s*}/g, '}').replace(/,\s*\]/g, ']');
  
  // Add missing commas between value and next property
  cleaned = cleaned.replace(/("[^"]*")\s*("[^"]*")\s*:/g, '$1,$2:');
  cleaned = cleaned.replace(/(true|false|null|\d+)\s*("[^"]*")\s*:/g, '$1,$2:');
  cleaned = cleaned.replace(/(\}|\])\s*("[^"]*")\s*:/g, '$1,$2:');
  
  // Add quotes to unquoted keys
  cleaned = cleaned.replace(/(\{|\,)\s*([a-zA-Z0-9_]+)\s*:/g, '$1"$2":');
  
  // Fix missing quotes around string values
  cleaned = cleaned.replace(/:\s*([a-zA-Z0-9_]+)(\s*[,\}\]])/g, ':"$1"$2');
  
  // Fix missing commas between properties
  cleaned = cleaned.replace(/}\s*{/g, '},{');
  cleaned = cleaned.replace(/]\s*{/g, '],{');
  cleaned = cleaned.replace(/}\s*\[/g, '},[');
  cleaned = cleaned.replace(/]\s*\[/g, '],[');
  
  // Ensure closing brackets and quotes
  if ((cleaned.match(/\{/g) || []).length > (cleaned.match(/\}/g) || []).length) {
    cleaned += '}';
  }
  if ((cleaned.match(/\[/g) || []).length > (cleaned.match(/\]/g) || []).length) {
    cleaned += ']';
  }
  
  // Final attempt to make it parsable - sometimes it's better to just extract individual instructions
  try {
    JSON.parse(cleaned);
    return cleaned;
  } catch (e) {
    // If we still can't parse it, let's try a more drastic approach for agent instructions
    if (cleaned.includes('Agent1_instructions') || 
        cleaned.includes('Agent2_instructions') || 
        cleaned.includes('Agent3_instructions')) {
      
      // Just extract each agent instruction into a new, clean object
      const newObj = {};
      
      // Use regex to extract each instruction
      const agent1Match = cleaned.match(/"?Agent1_instructions"?\s*:\s*"([^"]*)/);
      const agent2Match = cleaned.match(/"?Agent2_instructions"?\s*:\s*"([^"]*)/);
      const agent3Match = cleaned.match(/"?Agent3_instructions"?\s*:\s*"([^"]*)/);
      
      if (agent1Match && agent1Match[1]) newObj.Agent1_instructions = agent1Match[1];
      if (agent2Match && agent2Match[1]) newObj.Agent2_instructions = agent2Match[1];
      if (agent3Match && agent3Match[1]) newObj.Agent3_instructions = agent3Match[1];
      
      // Return a properly formatted JSON object
      return JSON.stringify(newObj);
    }
    
    // If all else fails, return the best we could do
    return cleaned;
  }
}

// Function to create a user-friendly JSON error display
function createJsonErrorDisplay(jsonText, error) {
  let html = `<div class="json-block">`;
  html += `<div class="json-error-label">JSON Format Error: ${error.message}</div>`;
  
  // First attempt to directly extract and display agent instructions without JSON parsing
  if (jsonText.includes('Agent1_instructions') || 
      jsonText.includes('Agent2_instructions') || 
      jsonText.includes('Agent3_instructions')) {
    
    html += extractAndFormatAgentInstructions(jsonText);
    html += `<div class="json-note">Note: JSON could not be parsed, but instructions were extracted.</div>`;
    html += `</div>`;
    return html;
  }
  
  // If not agent instructions, create a more readable fallback display
  html += `<div class="json-fallback">`;
  
  let formatted = jsonText
    // Add line breaks and highlight
    .replace(/\{/g, '{\n')
    .replace(/\}/g, '\n}')
    .replace(/\[/g, '[\n')
    .replace(/\]/g, '\n]')
    .replace(/,/g, ',\n')
    .replace(/(".*?"):/g, '<span class="json-property-name">$1</span>:')
    .replace(/:(\s*".*?")/g, ': <span class="json-string">$1</span>');
  
  html += `<pre>${formatted}</pre>`;
  html += `</div>`;
  html += `</div>`;
  
  return html;
}

// Function to extract and format agent instructions from malformed JSON
function extractAndFormatAgentInstructions(jsonText) {
  let html = '<div class="agent-instructions">';
  
  // Extract instructions using more robust patterns
  // Look for patterns like Agent1_instructions:"content" or "Agent1_instructions":"content"
  const extractInstruction = (agentNum) => {
    const patterns = [
      new RegExp(`"?Agent${agentNum}_instructions"?\\s*:\\s*"([^"]*)"`, 'i'),
      new RegExp(`"?Agent${agentNum}_instructions"?\\s*:\\s*"(.*?)(?:"\\s*,|"\\s*}|$)`, 'is'),
      new RegExp(`"?Agent${agentNum}_instructions"?\\s*:\\s*([^",}]*)`, 'i')
    ];
    
    for (const pattern of patterns) {
      const match = jsonText.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }
    return null;
  };
  
  // Try to extract each instruction
  const agent1Content = extractInstruction(1);
  const agent2Content = extractInstruction(2);
  const agent3Content = extractInstruction(3);
  
  // Create blocks for each instruction found
  if (agent1Content) {
    html += createInstructionBlock('1', agent1Content);
  }
  
  if (agent2Content) {
    html += createInstructionBlock('2', agent2Content);
  }
  
  if (agent3Content) {
    html += createInstructionBlock('3', agent3Content);
  }
  
  html += '</div>';
  return html;
}

// Helper function to create instruction block HTML
function createInstructionBlock(number, content) {
  return `
    <div class="instruction-block">
      <h3>Scientist ${number} Instructions</h3>
      <div class="instruction-content">${escapeHtml(content).replace(/\\n/g, '<br>')}</div>
    </div>
  `;
}

// Function to format JSON object as HTML
function formatJsonAsHtml(json) {
  // Create the JSON viewer container
  let html = '<div class="json-viewer">';
  
  // Format agent instructions when it's the expected structure
  if (json.Agent1_instructions || json.Agent2_instructions || json.Agent3_instructions) {
    html += formatAgentInstructions(json);
  } else {
    // Generic JSON formatting
    html += '<div class="json-content">';
    html += formatJsonNode(json, 0);
    html += '</div>';
  }
  
  html += '</div>';
  return html;
}

// Function to format agent instructions
function formatAgentInstructions(json) {
  let html = '<div class="agent-instructions">';
  
  // Process each agent's instructions
  Object.keys(json).forEach(key => {
    if (key.includes('instructions')) {
      const agentNumber = key.match(/Agent(\d+)/i)?.[1] || '';
      const instructions = json[key];
      
      html += `<div class="instruction-block">`;
      html += `<h3>Scientist ${agentNumber} Instructions</h3>`;
      html += `<div class="instruction-content">${escapeHtml(instructions)}</div>`;
      html += `</div>`;
    }
  });
  
  html += '</div>';
  return html;
}

// Function to recursively format JSON nodes
function formatJsonNode(node, level) {
  if (node === null) return '<span class="json-null">null</span>';
  
  if (typeof node === 'undefined') return '<span class="json-undefined">undefined</span>';
  
  if (typeof node === 'boolean') {
    return `<span class="json-boolean">${node}</span>`;
  }
  
  if (typeof node === 'number') {
    return `<span class="json-number">${node}</span>`;
  }
  
  if (typeof node === 'string') {
    return `<span class="json-string">"${escapeHtml(node)}"</span>`;
  }
  
  if (Array.isArray(node)) {
    if (node.length === 0) return '<span class="json-array">[]</span>';
    
    let html = '<span class="json-array">[<div class="json-array-items">';
    
    node.forEach((item, index) => {
      html += '<div class="json-array-item">';
      html += formatJsonNode(item, level + 1);
      if (index < node.length - 1) html += ',';
      html += '</div>';
    });
    
    html += '</div>]</span>';
    return html;
  }
  
  if (typeof node === 'object') {
    const keys = Object.keys(node);
    if (keys.length === 0) return '<span class="json-object">{}</span>';
    
    let html = '<span class="json-object">{<div class="json-object-properties">';
    
    keys.forEach((key, index) => {
      html += '<div class="json-property">';
      html += `<span class="json-property-name">"${escapeHtml(key)}"</span>: `;
      html += formatJsonNode(node[key], level + 1);
      if (index < keys.length - 1) html += ',';
      html += '</div>';
    });
    
    html += '</div>}</span>';
    return html;
  }
  
  return `<span class="json-unknown">${typeof node}</span>`;
}

// Helper function to escape HTML special characters
function escapeHtml(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// Helper function to apply inline formatting (bold, italic, etc.)
function applyInlineFormatting(text) {
  // Bold formatting (** or __)
  text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  text = text.replace(/__(.*?)__/g, '<strong>$1</strong>');
  
  // Italic formatting (* or _)
  text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
  text = text.replace(/_(.*?)_/g, '<em>$1</em>');
  
  // Handle potential line breaks within paragraphs
  text = text.replace(/\n/g, '<br>');
  
  return text;
}

// Function to load content from a file
async function loadContent(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load ${url}: ${response.status} ${response.statusText}`);
    }
    const text = await response.text();
    return formatContent(text);
  } catch (error) {
    console.error(`Error loading content from ${url}:`, error);
    return `<p class="error">Failed to load content. ${error.message}</p>`;
  }
}

// Function to load and populate all agent content
async function loadAllAgentContent() {
  // Get all agent content divs
  const agentContentDivs = document.querySelectorAll('.agent-content');
  
  // Get current iteration and model
  const currentIteration = parseInt(document.getElementById('iteration-display').textContent.replace('Iteration ', '')) || 1;
  const currentModel = document.getElementById('model-select').value;
  
  // For each agent content div
  for (const agentDiv of agentContentDivs) {
    const agentId = agentDiv.id;
    
    // Check if this agent has configurations
    if (!window.agentResultsConfig[agentId]) {
      console.warn(`No result configuration found for agent: ${agentId}`);
      continue;
    }
    
    // For each model (claude, gemini)
    for (const model of ['claude', 'gemini']) {
      // For each available iteration
      for (const iterationKey of Object.keys(window.agentResultsConfig[agentId][model])) {
        const iteration = parseInt(iterationKey);
        
        // Get the file path from the configuration
        const filePath = window.agentResultsConfig[agentId][model][iteration];
        if (!filePath) continue;
        
        try {
          // Get the output content container for this agent, iteration, and model
          const outputContentContainer = agentDiv.querySelector(`.output-content.iteration-${iteration} .${model}-content`);
          if (!outputContentContainer) {
            console.warn(`No output container found for agent: ${agentId}, iteration: ${iteration}, model: ${model}`);
            // Attempt to create the container if it doesn't exist
            // This shouldn't be necessary if generateAgentOutputHTML is working correctly, but adding as a safeguard
            const iterationContainer = agentDiv.querySelector(`.output-content.iteration-${iteration}`);
            if (iterationContainer) {
              const newModelContent = document.createElement('div');
              newModelContent.className = `${model}-content`;
              iterationContainer.appendChild(newModelContent);
              // Now we can use this container
              const content = await loadContent(filePath);
              newModelContent.innerHTML = content + `<p class="model-badge ${model}">${model === 'claude' ? 'Claude 3.5 Sonnet' : 'Gemini 2.0 Flash'}</p>`;
            } else {
              console.error(`Cannot find or create iteration container for agent: ${agentId}, iteration: ${iteration}`);
            }
            continue;
          }
          
          // Load the content and update the container
          const content = await loadContent(filePath);
          
          // Set the innerHTML of the container, preserving the model badge
          const modelBadge = outputContentContainer.querySelector(`.model-badge.${model}`);
          if (modelBadge) {
            outputContentContainer.innerHTML = content + modelBadge.outerHTML;
          } else {
            outputContentContainer.innerHTML = content + `<p class="model-badge ${model}">${model === 'claude' ? 'Claude 3.5 Sonnet' : 'Gemini 2.0 Flash'}</p>`;
          }
        } catch (error) {
          console.error(`Error loading content for agent: ${agentId}, iteration: ${iteration}, model: ${model}`, error);
        }
      }
    }
  }
  
  // Update iteration navigation based on available iterations
  updateIterationNavigation();
}

// Function to update the iteration navigation controls
function updateIterationNavigation() {
  const prevIterationBtn = document.getElementById('prev-iteration');
  const nextIterationBtn = document.getElementById('next-iteration');
  const currentIterationDisplay = document.getElementById('iteration-display');
  const currentIteration = parseInt(currentIterationDisplay.textContent.replace('Iteration ', '')) || 1;
  
  // Find maximum available iteration across all agents
  let maxIteration = 1;
  Object.keys(window.agentResultsConfig).forEach(agentId => {
    Object.keys(window.agentResultsConfig[agentId]['claude']).forEach(iteration => {
      const iterNum = parseInt(iteration);
      if (iterNum > maxIteration) {
        maxIteration = iterNum;
      }
    });
  });
  
  // Update button states
  prevIterationBtn.disabled = currentIteration <= 1;
  nextIterationBtn.disabled = currentIteration >= maxIteration;
  
  // Note: The visibility toggle for iterations is now handled in script.js
}

// Note: We don't need this function anymore as it's handled by script.js
// Keeping the function signature for backwards compatibility but removing its implementation
function handleIterationNavigation(direction) {
  // This is now handled in script.js
  console.log("Iteration change handled by script.js");
}

// Function to generate the dynamic HTML structure for agent outputs
function generateAgentOutputHTML() {
  // Ensure all necessary iteration containers exist
  for (const agentId of Object.keys(window.agentResultsConfig)) {
    console.log(`Generating HTML for agent: ${agentId}`);
    
    // Find the agent container
    const agentContainer = document.getElementById(agentId);
    
    if (!agentContainer) {
      console.warn(`No container found for agent: ${agentId}, ID might be mismatched`);
      continue;
    }
    
    // Get or create the agent output container
    let agentOutput = agentContainer.querySelector('.agent-output');
    if (!agentOutput) {
      agentOutput = document.createElement('div');
      agentOutput.className = 'agent-output';
      agentContainer.appendChild(agentOutput);
    }
    
    // Add heading if not present
    if (!agentOutput.querySelector('h3')) {
      const heading = document.createElement('h3');
      heading.textContent = 'Output';
      agentOutput.appendChild(heading);
    }
    
    // Get max iteration number from configuration
    const maxIteration = getMaxIterationNumber(agentId);
    console.log(`Max iteration for ${agentId}: ${maxIteration}`);
    
    // Generate HTML for each iteration
    for (let i = 1; i <= maxIteration; i++) {
      // Create iteration container if it doesn't exist
      let iterationContainer = agentOutput.querySelector(`.output-content.iteration-${i}`);
      if (!iterationContainer) {
        iterationContainer = document.createElement('div');
        iterationContainer.className = `output-content iteration-${i}`;
        // Hide all iterations except the first one
        if (i > 1) {
          iterationContainer.style.display = 'none';
        }
        agentOutput.appendChild(iterationContainer);
      }
      
      // Create content divs for each model
      ['gemini', 'claude'].forEach(model => {
        let modelContent = iterationContainer.querySelector(`.${model}-content`);
        if (!modelContent) {
          modelContent = document.createElement('div');
          modelContent.className = `${model}-content`;
          
          // Add loading indicator
          const loading = document.createElement('p');
          loading.className = 'loading';
          loading.textContent = `Loading ${model.charAt(0).toUpperCase() + model.slice(1)} results...`;
          modelContent.appendChild(loading);
          
          // Add model badge
          const badge = document.createElement('p');
          badge.className = `model-badge ${model}`;
          badge.textContent = model === 'gemini' ? 'Gemini 2.0 Flash' : 'Claude 3.5 Sonnet';
          modelContent.appendChild(badge);
          
          iterationContainer.appendChild(modelContent);
        }
      });
    }
  }
}

// Helper function to get the maximum iteration number for an agent
function getMaxIterationNumber(agentId) {
  if (!window.agentResultsConfig[agentId]) return 1;
  
  let maxIteration = 1;
  
  // Check both claude and gemini configurations
  ['claude', 'gemini'].forEach(model => {
    if (window.agentResultsConfig[agentId][model]) {
      const iterations = Object.keys(window.agentResultsConfig[agentId][model])
        .map(k => parseInt(k))
        .filter(k => !isNaN(k));
      
      if (iterations.length > 0) {
        const max = Math.max(...iterations);
        if (max > maxIteration) {
          maxIteration = max;
        }
      }
    }
  });
  
  return maxIteration;
}

// Function to initialize the automatic loading
function initResultsLoader() {
  // Generate the dynamic HTML structure first
  generateAgentOutputHTML();
  
  // Load all agent content
  loadAllAgentContent();
  
  // Set up model selection handler
  document.getElementById('model-select').addEventListener('change', () => {
    // Update model visibility
    const selectedModel = document.getElementById('model-select').value;
    document.querySelectorAll('.claude-content, .gemini-content').forEach(content => {
      if (content.classList.contains(`${selectedModel}-content`)) {
        content.style.display = 'block';
      } else {
        content.style.display = 'none';
      }
    });
  });
}

// Make sure to initialize the results loader after the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  initResultsLoader();
}); 